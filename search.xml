<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CGroups & Namespaces]]></title>
    <url>%2F2019%2F05%2F13%2FDocker%2FCGroups%20%26%20Namespaces%2F</url>
    <content type="text"><![CDATA[CGroups控制进程可以使用多少资源。通过添加限制，您可以确保有足够的可用空间，从而为应用程序提供有保证的服务质量。还可以保护系统免受潜在恶意用户通过资源耗尽执行拒绝服务（DoS）的影响。还可以通过定义上边界来限制应用程序的内存泄漏或其他编程错误。While cgroups control how much resources a process can use, Namespaces control what a process and see and access. 以下是已存在的cgroup和Namespace类型的一些示例：1234567891011121314151617# CGroups Examples --cpu-shares --cpuset-cpus --memory-reservation --kernel-memory --blkio-weight (block IO) --device-read-iops --device-write-iops # Namespace ExamplesCgroup CLONE_NEWCGROUP Cgroup root directory IPC CLONE_NEWIPC System V IPC, POSIX message queues Network CLONE_NEWNET Network devices, stacks, ports, etc. Mount CLONE_NEWNS Mount points PID CLONE_NEWPID Process IDs User CLONE_NEWUSER User and group IDs UTS CLONE_NEWUTS Hostname and NIS domain name 1. Define Memory Limits12345678# 启动一个container[root@host01 ~]# docker run -d --name mb100 --memory 100m alpine top77f0cf817a50bf973bc4347fce10318ee969716a2e703b6cb77875c0e007075d# 查看资源占用情况[root@host01 ~]# docker stats --no-streamCONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS77f0cf817a50 mb100 0.00% 376KiB / 100MiB 0.37% 4.53kB / 180B 1.03MB / 0B 1[root@ 2. Define CPU Shares虽然内存限制定义了设置的最大值，但CPU限制基于共享份额。这些份额是一个进程应该与另一个进程占用CPU运行多少处理时间之间的权重。如果CPU处于空闲状态，则该进程将使用所有可用资源。如果第二个进程需要CPU，则将根据权重共享可用的CPU时间。EX:下面我们将启动具有不同共享份额的容器示例。该示例的--cpu-shares参数定义0-768之间的份额。如果容器定义了768的份额，而另一个容器定义了256的份额，则第一个容器将拥有75％的份额，而另一个容器具有25％的可用份额。这些数字是由于CPU共享的加权方法而不是固定容量。第一个容器下面将允许拥有75％的份额。第二个容器将限制在25％。需要注意的是：如果没有其他进程正在运行，当前进程可以拥有100％的份额，无论定义的权重如何。123456789101112131415161718192021222324[root@host01 ~]#[root@host01 ~]# docker run -d --name c768 --cpuset-cpus 0 --cpu-shares 768 benhall/stressUnable to find image &apos;benhall/stress:latest&apos; locallylatest: Pulling from benhall/stressa64038a0eeaa: Pull complete2ec6e7edf8a8: Pull complete0a5fb6c3c94b: Pull completea3ed95caeb02: Pull completed7d894700fdc: Pull completeDigest: sha256:4310809ff7c6bcb4a31bede2b7866c15862b4fd0e6597e72fc7c9cd900f77a1host01 ~]#Status: Downloaded newer image for benhall/stress:latest48877d7c5e928f7adbdd410107733b2e53886542ef4662dd4c9546fe7f079ab2[root@host01 ~]# docker run -d --name c256 --cpuset-cpus 0 --cpu-shares 256 benhall/stresse0d6ca2bb797a830e20b6d20dbe1c3d1139e38804af7b85ec19dabdc3eec156f[root@host01 ~]# sleep 5[root@host01 ~]# docker stats --no-streamCONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDSe0d6ca2bb797 c256 25.07% 716KiB / 737.5MiB 0.09% 2.86kB / 90B 0B / 0B 348877d7c5e92 c768 74.14% 724KiB / 737.5MiB 0.10% 3.91kB / 90B 0B / 0B 377f0cf817a50 mb100 0.00% 364KiB / 100MiB 0.36% 10.4kB / 180B 1.03MB / 0B 1[root@host01 ~]# docker rm -f c768 c256c768c256[root@host01 ~]# 3. Use Network Namespace 虽然cgroup控制进程可以使用多少资源，但Namespace控制进程以及查看和访问的内容。 我们启动容器时，Docker将定义并创建网络接口,这为容器提供了唯一的IP地址和接口。12345678910[root@host01 ~]# docker run -it alpine ip addr show1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever10: eth0@if11: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP link/ether 02:42:ac:12:00:03 brd ff:ff:ff:ff:ff:ff inet 172.18.0.3/24 brd 172.18.0.255 scope global eth0 valid_lft forever preferred_lft forever[root@host01 ~]# 通过将命名空间更改为host，而不是通过其接口隔离容器的网络，该进程将可以访问主机网络接口。如果进程侦听端口，它们将在主机接口上被侦听并映射到容器内。123456789101112131415161718192021222324[root@host01 ~]# docker run -it --net=host alpine ip addr show1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP qlen 1000 link/ether 02:42:ac:11:00:06 brd ff:ff:ff:ff:ff:ff inet 172.17.0.6/16 brd 172.17.255.255 scope global ens3 valid_lft forever preferred_lft forever inet6 fe80::e65d:1b34:8170:b889/64 scope link valid_lft forever preferred_lft forever3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP link/ether 02:42:b6:11:ca:22 brd ff:ff:ff:ff:ff:ff inet 172.18.0.1/24 brd 172.18.0.255 scope global docker0 valid_lft forever preferred_lft forever inet6 fe80::3a01:843e:2449:cda5/64 scope link valid_lft forever preferred_lft forever5: veth7551bb3@if4: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue master docker0 state UP link/ether d6:99:5b:ca:51:3f brd ff:ff:ff:ff:ff:ff inet6 fe80::ee0c:c450:959d:3564/64 scope link valid_lft forever preferred_lft forever[root@host01 ~]# 4. Use Pid Namespace与Network Namespace一样，容器可以看到的进程也取决于它所属的命名空间。通过更改Pid Namespace，可以让容器与超出其正常范围的进程进行交互。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# 1. 启动一个容器，使用命令查看容器中的进程[root@host01 ~]# docker run -it alpine ps auxPID USER TIME COMMAND 1 root 0:00 ps aux# 2. 带上`--pid=host`参数再启动一个容器，使用命令查看容器中的进程 [root@host01 ~]# docker run -it --pid=host alpine ps auxPID USER TIME COMMAND 1 root 0:01 /usr/lib/systemd/systemd 2 root 0:00 [kthreadd] 4 root 0:00 [kworker/0:0H] 5 root 0:00 [kworker/u2:0] 6 root 0:00 [mm_percpu_wq] 7 root 0:00 [ksoftirqd/0] 8 root 0:00 [rcu_sched] 9 root 0:00 [rcu_bh] 10 root 0:00 [migration/0] 11 root 0:00 [watchdog/0] 12 root 0:00 [cpuhp/0] 13 root 0:00 [kdevtmpfs] 14 root 0:00 [netns] 15 root 0:00 [khungtaskd] 16 root 0:00 [oom_reaper] 17 root 0:00 [writeback] 18 root 0:00 [kcompactd0] 19 root 0:00 [ksmd] 20 root 0:00 [khugepaged] 21 root 0:00 [crypto] 22 root 0:00 [kintegrityd] 23 root 0:00 [kblockd] 24 root 0:00 [edac-poller] 25 root 0:00 [devfreq_wq] 26 root 0:00 [watchdogd] 29 root 0:00 [kswapd0] 67 root 0:00 [kthrotld] 68 root 0:00 [ipv6_addrconf] 77 root 0:00 [kstrp] 134 root 0:00 [ata_sff] 135 root 0:00 [scsi_eh_0] 136 root 0:00 [scsi_tmf_0] 137 root 0:00 [kworker/0:1H] 138 root 0:00 [scsi_eh_1] 139 root 0:00 [scsi_tmf_1] 140 root 0:00 [kworker/u2:2] 143 root 0:00 [kworker/u2:3] 151 root 0:00 [kworker/u3:0] 163 root 0:00 [jbd2/vda1-8] 164 root 0:00 [ext4-rsv-conver] 185 root 0:00 /usr/lib/systemd/systemd-journald 203 root 0:00 /usr/lib/systemd/systemd-udevd 207 62583 0:00 /usr/lib/systemd/systemd-timesyncd 209 63822 0:00 /usr/lib/systemd/systemd-networkd 221 61662 0:00 /usr/lib/systemd/systemd-resolved 225 81 0:00 /usr/bin/dbus-daemon --system --address=systemd: --nofork 226 root 0:00 /usr/lib/systemd/systemd-logind 232 root 0:00 /usr/bin/dhcpcd -q -b 237 root 0:00 /sbin/agetty -o -p -- \u --noclear tty1 linux 242 root 0:00 /sbin/agetty -o -p -- \u --keep-baud 115200,38400,9600 tty 245 root 0:00 [cfg80211] 260 root 0:00 [ttm_swap] 265 root 0:10 /usr/bin/dockerd --bip=172.18.0.1/24 -H 0.0.0.0:2345 --sto 285 root 0:02 docker-containerd --config /var/run/docker/containerd/cont 548 root 0:00 sshd: root@pts/0 551 root 0:00 /usr/lib/systemd/systemd --user 552 root 0:00 (sd-pam) 560 root 0:00 -bash 842 root 0:00 docker-containerd-shim -namespace moby -workdir /var/lib/d 857 root 0:00 top 1593 root 0:00 [kworker/0:2] 1950 root 0:00 [kworker/0:0] 2022 root 0:00 [kworker/0:1] 2268 root 0:00 docker run -it --pid=host alpine ps aux 2312 root 0:00 docker-containerd-shim -namespace moby -workdir /var/lib/d 2328 root 0:00 ps aux 2393 root 0:00 [dhcpcd-run-hook] 2394 root 0:00 docker-runc --root /var/run/docker/runtime-runc/moby --log[root@host01 ~]# 5. Use Pid Namespace有时我们需要使用--net=host让容器访问主机资源，例如调试工具，但这被认为是不好的做法。这是因为您正在打破容器安全模型，这可能会引入漏洞。相反，如果需要，建议使用共享命名空间来访问容器所需的命名空间。 我们启动一个Nginx容器，这个过程将定义一个新的network namespace和pid namespace。Nginx服务器将自身绑定到新定义的网络接口的端口80。1234567891011[root@host01 ~]# docker run -d --name http nginx:alpineUnable to find image &apos;nginx:alpine&apos; locallyalpine: Pulling from library/nginx8e402f1a9c57: Pull complete56b0d9b69cc9: Pull completeb66c8bb200cc: Pull complete4ec77fc9c55f: Pull completeDigest: sha256:9343ab33dfc65b63b5733659139d671786f5e3404d93ad8bf3b00df2609b2635Status: Downloaded newer image for nginx:alpinebc1a0efd587ce2c2a9eca4845e1533cc4f676d842def28114b48a0f5d2ba695a[root@host01 ~]# 其他容器现在可以使用语法重用此命名空间container:&lt;name&gt;。curl命令可以访问在localhost上运行的HTTP服务器，因为它们共享相同的网络接口。12345678910111213141516171819202122232425262728293031323334[root@host01 ~]# docker run --net=container:http benhall/curl curl -s localhostUnable to find image &apos;benhall/curl:latest&apos; locallylatest: Pulling from benhall/curl12b41071e6ce: Pull completefb1cef6edba2: Pull completea3ed95caeb02: Pull completeDigest: sha256:637b3e063550593071b172916c896ea3590d4ecd67ae2399e54672b5770e114eStatus: Downloaded newer image for benhall/curl:latest&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt; body &#123; width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;[root@host01 ~]# 我们还可以查看共享容器中的进程并与之交互。1234567[root@host01 ~]#[root@host01 ~]# docker run --pid=container:http alpine ps auxPID USER TIME COMMAND 1 root 0:00 nginx: master process nginx -g daemon off; 5 100 0:00 nginx: worker process 6 root 0:00 ps aux[root@host01 ~]# 这对于调试工具很有用，例如strace。这允许我们在不更改或重新启动应用程序的情况下为特定容器提供更多权限。]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 常用命令]]></title>
    <url>%2F2019%2F05%2F12%2FDocker%2FDocker%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[启动容器，使用-v参数共享目录： 1docker run -i -t --name Centos-JDK8 -v /apps/soft:/apps/soft centos7.3 /bin/bash 提交镜像 12# 格式：docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]docker commit -m &quot;Centos7.3 with JDK8.&quot; -a &quot;Michael Wu&quot; bd0ff3db8f84 devops/centos7.3:JDK8 标记镜像 12# 格式：docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]docker tag devops/centos7.3:JDK8 michaelwu/devops/centos7.3:JDK8 推送镜像 12345[root@mvxl1678 ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEmichaelwu/devops/centos7.3 JDK8 a055d79b8e52 7 minutes ago 693 MB[root@mvxl1678 ~]# docker push michaelwu/devops/centos7.3:JDK8 可以用prune命令删除不用的资源，比如： 1234# 删除不用的imagedocker image prune -a# 删除不用的卷docker volume prune 显示所有的容器，过滤出Exited状态的容器，取出这些容器的IDsudo docker ps -a|grep Exited|awk &#39;{print $1}&#39; 查询所有的容器，过滤出Exited状态的容器，列出容器ID，删除这些容器sudo docker rm $(docker ps -a|grep Exited|awk &#39;{print $1}&#39;)或者sudo docker rm $(sudo docker ps -qf status=exited) 删除所有未运行的容器（已经运行的删除不了，未运行的就一起被删除了）sudo docker rm $(sudo docker ps -a -q) 删除孤立的容器(Docker 1.13版本以后)sudo docker container prune 命令查看磁盘使用情况du -hs /var/lib/docker/ 查看Docker的磁盘使用情况docker system df 清理磁盘，删除关闭的容器、无用的数据卷和网络，以及dangling镜像(即无tag的镜像)docker system prune 迁移/var/lib/docker目录下面的文件到/apps/data/dockerrsync -avz /var/lib/docker /apps/data/docker/ 删除 docker0 虚拟网卡 12# 用ip命令使`docker0`网卡down掉,然后在删除网卡ip link set dev docker0 down &amp;&amp; brctl delbr docker0 删除桥接网络flannel.1ifconfig flannel.1 down &amp;&amp; ip link del flannel.1 清理iptablesiptables -F &amp;&amp; iptables -t nat -F &amp;&amp; iptables -t mangle -F &amp;&amp; iptables -t raw -F &amp;&amp; iptables -X &amp;&amp; iptables -A FORWARD -j ACCEPT 重建docker0网络 123456# 停止Dockersystemctl stop docker # 重建网络iptables -t nat -F &amp;&amp; ifconfig docker0 down &amp;&amp; brctl delbr docker0 &amp;&amp; docker -d# 启动Dockersystemctl start docker 经过验证发现，当我们使用iptables -t nat -F清理iptables或其他误操作破坏了Docker0网络，可以采用启动Docker的方式自动创建docker0网络。systemctl stop docker &amp;&amp; ifconfig docker0 down &amp;&amp; brctl delbr docker0 &amp;&amp; systemctl start docker 运行完命令及删除容器docker run -it --rm maven:3.6.1-jdk-7 mvn version 特权模式运行容器docker run -it --privileged ubuntu bash]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7下Docker安装与配置]]></title>
    <url>%2F2019%2F05%2F07%2FDocker%2FCentOS7%E4%B8%8BDocker%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1. 主机名配置因为K8S的规定，主机名只支持包含 - 和 .(中横线和点)两种特殊符号，并且主机名不能出现重复。 2. Hosts配置每台主机的hosts(/etc/hosts),添加host_ip $hostname到/etc/hosts文件中。 3. CentOS关闭selinuxsudo sed -i &#39;s/SELINUX=enforcing/SELINUX=disabled/g&#39; /etc/selinux/config 4. 关闭防火墙(可选)或者放行相应端口对于刚刚接触Rancher的用户，建议在关闭防火墙的测试环境或桌面虚拟机来运行rancher，以避免出现网络通信问题。 关闭防火墙1、CentOSsystemctl stop firewalld.service &amp;&amp; systemctl disable firewalld.service2、Ubuntuufw disable 5. 配置主机时间、时区、系统语言 查看时区date -R或者timedatectl 修改时区ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 修改系统语言环境sudo echo &#39;LANG=&quot;en_US.UTF-8&quot;&#39; &gt;&gt; /etc/profile;source /etc/profile 配置主机NTP时间同步 6. Kernel性能调优12345678910cat &gt;&gt; /etc/sysctl.conf &lt;&lt;EOFvm.swappiness = 10net.ipv4.ip_forward=1net.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1net.bridge.bridge-nf-call-arptables = 1net.ipv4.neigh.default.gc_thresh1=4096net.ipv4.neigh.default.gc_thresh2=6144net.ipv4.neigh.default.gc_thresh3=8192EOF 数值根据实际环境自行配置，最后执行sysctl -p保存配置。 7. 内核模块检查 模块查询: lsmod | grep &lt;模块名&gt;模块加载: modprobe &lt;模块名&gt; 8. ETCD集群容错建议在ETCD集群中使用奇数个成员,通过添加额外成员可以获得更高的失败容错。具体详情可以查阅optimal-cluster-size。 Docker安装与配置1. 安装 修改系统yum源12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455sudo cp /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bakcat &gt; /etc/yum.repos.d/CentOS-Base.repo &lt;&lt; EOF[base]name=CentOS-$releasever - Base - mirrors.aliyun.comfailovermethod=prioritybaseurl=http://mirrors.aliyun.com/centos/$releasever/os/$basearch/ http://mirrors.aliyuncs.com/centos/$releasever/os/$basearch/ http://mirrors.cloud.aliyuncs.com/centos/$releasever/os/$basearch/gpgcheck=1gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7#released updates[updates]name=CentOS-$releasever - Updates - mirrors.aliyun.comfailovermethod=prioritybaseurl=http://mirrors.aliyun.com/centos/$releasever/updates/$basearch/ http://mirrors.aliyuncs.com/centos/$releasever/updates/$basearch/ http://mirrors.cloud.aliyuncs.com/centos/$releasever/updates/$basearch/gpgcheck=1gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7#additional packages that may be useful[extras]name=CentOS-$releasever - Extras - mirrors.aliyun.comfailovermethod=prioritybaseurl=http://mirrors.aliyun.com/centos/$releasever/extras/$basearch/ http://mirrors.aliyuncs.com/centos/$releasever/extras/$basearch/ http://mirrors.cloud.aliyuncs.com/centos/$releasever/extras/$basearch/gpgcheck=1gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7#additional packages that extend functionality of existing packages[centosplus]name=CentOS-$releasever - Plus - mirrors.aliyun.comfailovermethod=prioritybaseurl=http://mirrors.aliyun.com/centos/$releasever/centosplus/$basearch/ http://mirrors.aliyuncs.com/centos/$releasever/centosplus/$basearch/ http://mirrors.cloud.aliyuncs.com/centos/$releasever/centosplus/$basearch/gpgcheck=1enabled=0gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7#contrib - packages by Centos Users[contrib]name=CentOS-$releasever - Contrib - mirrors.aliyun.comfailovermethod=prioritybaseurl=http://mirrors.aliyun.com/centos/$releasever/contrib/$basearch/ http://mirrors.aliyuncs.com/centos/$releasever/contrib/$basearch/ http://mirrors.cloud.aliyuncs.com/centos/$releasever/contrib/$basearch/gpgcheck=1enabled=0gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7EOF Docker-ce安装 因为CentOS的安全限制，通过RKE安装K8S集群时候无法使用root账户。所以，建议CentOS用户使用非root用户来运行docker,不管是RKE还是custom安装k8s,详情查看无法为主机配置SSH隧道。 1234567891011121314151617181920212223242526272829303132333435# 添加用户(可选)sudo adduser `&lt;new_user&gt;`# 为新用户设置密码sudo passwd `&lt;new_user&gt;`# 为新用户添加sudo权限sudo echo &apos;&lt;new_user&gt; ALL=(ALL) ALL&apos; &gt;&gt; /etc/sudoers# 卸载旧版本Docker软件sudo yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine \ container*# 定义安装版本export docker_version=18.06.2.ce-3.el7# step 1: 安装必要的一些系统工具sudo yum update -ysudo yum install -y yum-utils device-mapper-persistent-data lvm2 bash-completion# Step 2: 添加软件源信息sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# Step 3: 更新并安装 Docker-CEsudo yum clean all;yum makecache allversion=$(yum list docker-ce.x86_64 --showduplicates | sort -r|grep $&#123;docker_version&#125;|awk &apos;&#123;print $2&#125;&apos;)sudo yum -y install --setopt=obsoletes=0 docker-ce-$&#123;version&#125; docker-ce-selinux-$&#123;version&#125;# 如果已经安装高版本Docker,可进行降级安装(可选)yum downgrade --setopt=obsoletes=0 -y docker-ce-$&#123;version&#125; docker-ce-selinux-$&#123;version&#125;# 把当前用户加入docker组sudo usermod -aG docker `&lt;new_user&gt;`# 设置开机启动sudo systemctl enable docker Docker配置对于通过systemd来管理服务的系统(比如CentOS7.X、Ubuntu16.X), Docker有两处可以配置参数: 一个是docker.service服务配置文件,一个是Docker daemon配置文件daemon.json。 docker.service对于CentOS系统，docker.service默认位于/usr/lib/systemd/system/docker.service；对于Ubuntu系统，docker.service默认位于/lib/systemd/system/docker.service使用此参数ExecStart=/usr/bin/dockerd --graph=/apps/data/docker --insecure-registry=harbor.xxx.com调整Docker镜像和container的存储位置,解决私有仓库https证书问题。 daemon.jsondaemon.json默认位于/etc/docker/daemon.json，如果没有可手动创建，基于systemd管理的系统都是相同的路径。通过修改daemon.json来改过Docker配置，也是Docker官方推荐的方法。 以下说明均基于systemd,并通过/etc/docker/daemon.json来修改配置。 配置镜像下载和上传并发数从Docker1.12开始，支持自定义下载和上传镜像的并发数，默认值上传为3个并发，下载为5个并发。通过添加”max-concurrent-downloads”和”max-concurrent-uploads”参数对其修改:12&quot;max-concurrent-downloads&quot;: 3,&quot;max-concurrent-uploads&quot;: 5 配置镜像加速地址 Rancher从v1.6.15开始到v2.x.x,Rancher系统相关的所有镜像(包括1.6.x上的K8S镜像)都托管在Dockerhub仓库。Dockerhub节点在国外，国内直接拉取镜像会有些缓慢。为了加速镜像的下载，可以给Docker配置国内的镜像地址。编辑/etc/docker/daemon.json加入以下内容:{“registry-mirrors”: [“https://7bezldxe.mirror.aliyuncs.com/&quot;,&quot;https://IP:PORT/&quot;]}可以设置多个registry-mirrors地址，以数组形式书写，地址需要添加协议头(https或者http)。 配置insecure-registries 私有仓库Docker默认只信任TLS加密的仓库地址(https)，所有非https仓库默认无法登陆也无法拉取镜像。insecure-registries字面意思为不安全的仓库，通过添加这个参数对非https仓库进行授信。可以设置多个insecure-registries地址，以数组形式书写，地址不能添加协议头(http)。 编辑/etc/docker/daemon.json加入以下内容:123&#123;&quot;insecure-registries&quot;: [&quot;192.168.1.100&quot;,&quot;IP:PORT&quot;]&#125; 配置Docker存储驱动OverlayFS是一个新一代的联合文件系统，类似于AUFS，但速度更快，实现更简单。Docker为OverlayFS提供了两个存储驱动程序:旧版的overlay，新版的overlay2(更稳定)。 先决条件: overlay2: Linux内核版本4.0或更高版本，或使用内核版本3.10.0-514+的RHEL或CentOS。 overlay: 主机Linux内核版本3.18+ 支持的磁盘文件系统 ext4(仅限RHEL 7.1) xfs(RHEL7.2及更高版本)，需要启用d_type=true。 &gt;具体详情参考 Docker Use the OverlayFS storage driver编辑/etc/docker/daemon.json加入以下内容1234&#123;&quot;storage-driver&quot;: &quot;overlay2&quot;,&quot;storage-opts&quot;: [&quot;overlay2.override_kernel_check=true&quot;]&#125; 配置日志驱动容器在运行时会产生大量日志文件，很容易占满磁盘空间。通过配置日志驱动来限制文件大小与文件的数量。 限制单个日志文件为100M,最多产生3个日志文件: 1234567&#123;&quot;log-driver&quot;: &quot;json-file&quot;,&quot;log-opts&quot;: &#123; &quot;max-size&quot;: &quot;100m&quot;, &quot;max-file&quot;: &quot;3&quot; &#125;&#125; Ubuntu\Debian系统 ，docker info提示WARNING: No swap limit supportUbuntu\Debian系统下，默认cgroups未开启swap account功能，这样会导致设置容器内存或者swap资源限制不生效。可以通过以下命令解决:12sudo sed -i &apos;s/GRUB_CMDLINE_LINUX=&quot;/GRUB_CMDLINE_LINUX=&quot;cgroup_enable=memory swapaccount=1 /g&apos; /etc/default/grubsudo update-grub 注意通过以上命令可自动配置参数，如果/etc/default/grub非默认配置，需根据实际参数做调整。提示以上配置完成后，建议重启一次主机。 – 我在本地/etc/docker/daemon.json文件内容：123456789101112&#123; &quot;registry-mirrors&quot;: [&quot;https://7bezldxe.mirror.aliyuncs.com/&quot;,&quot;https://3v68smwd.mirror.aliyuncs.com&quot;], &quot;max-concurrent-downloads&quot;: 3, &quot;max-concurrent-uploads&quot;: 5, &quot;storage-driver&quot;: &quot;overlay2&quot;, &quot;storage-opts&quot;: [&quot;overlay2.override_kernel_check=true&quot;], &quot;log-driver&quot;: &quot;json-file&quot;, &quot;log-opts&quot;: &#123; &quot;max-size&quot;: &quot;100m&quot;, &quot;max-file&quot;: &quot;3&quot; &#125;&#125; 1234# 记录几条可能用到的命令yum-config-manager --add-repo https://download.virtualbox.org/virtualbox/rpm/el/virtualbox.reposudo yum clean all;yum makecache allyum install VirtualBox-6.0]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitLab升级和数据迁移方案]]></title>
    <url>%2F2019%2F05%2F05%2FGitLab%2FGitlab%E5%8D%87%E7%BA%A7%E5%92%8C%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[不管是GitLab升级还是GitLab数据迁移，在实施之前我都必须要先做好Gitlab数据备份工作。 我们先来看看如何做GitLab的数据备份与恢复。GitLab自身提供了数据备份和恢复的工具:gitlab-rake,具体使用见下文： GitLab的数据备份与恢复GitLab自身提供了数据备份和恢复的工具:gitlab-rake,具体使用见下文： GitLab备份配置GitLab默认的备份目录是：/var/opt/gitlab/backups/，建议选择一个空间充足的目录进行配置。我们可以通过修改/etc/gitlab/gitlab.rb文件中的如下内容来调整备份路径: 1234# 备份目录gitlab_rails[&apos;backup_path&apos;] = &quot;/var/opt/gitlab/backups&quot;# 备份文件保留时间，单位：秒gitlab_rails[&apos;backup_keep_time&apos;] = 604800 GitLab数据备份1. 备份命令1/opt/gitlab/bin/gitlab-rake gitlab:backup:create CRON=1 备份操作比较简单，实际备份的数据会包含：数据库脚本、代码仓库、wiki、大文件、ssh用户秘钥等数据。An application data backup creates an archive file that contains the database, all repositories and all attachments. 2. 备份文件执行完备份命令后的备份数据是这样的：12345[root@node00 backups]# lltotal 127632268-rw------- 1 git git 43414650880 Nov 27 00:10 1543247502_2018_11_26_gitlab_backup.tar-rw------- 1 git git 43630172160 Nov 28 00:14 1543334067_2018_11_27_gitlab_backup.tar-rw------- 1 git git 43650590720 Nov 29 00:16 1543420454_2018_11_28_gitlab_backup.tar GitLab数据恢复1.恢复命令1gitlab-rake gitlab:backup:restore BACKUP=备份文件编号 2.恢复步骤a. 确保备份和恢复的GitLab应用版本相同 GitLab数据恢复需要确保新服务器上的GitLab的版本必须与创建备份时的Gitlab版本号相同. 比如新服务器安装的是9.1.2版本的GitLab, 那么迁移之前, 最好将旧服务器的GitLab 升级为9.1.2再进行备份. b. copy旧服务器上面的备份文件到新服务器1234# scp用法scp 用户名@IP: 文件名1 远程用户名@IP: 文件名2# scpscp root@node00:/var/opt/gitlab/backups/1543420454_2018_11_28_gitlab_backup.tar . c. 恢复步骤12345678910111213141516171819202122232425262728293031323334# 1. 先赋权[root@node01 backups]# pwd/apps/dbdat/gitlab/backups[root@node01 backups]# chown git.root /apps/dbdat/gitlab/backups[root@node01 gitlab]# chmod 700 /apps/dbdat/gitlab/backups[root@node01 gitlab]# ll /apps/dbdat/gitlab/total 8drwx------ 2 git root 4096 Nov 29 10:30 backups[root@node01 backups]# chown git.git 1543334067_2018_11_27_gitlab_backup.tar [root@node01 backups]# chmod 600 1543334067_2018_11_27_gitlab_backup.tar [root@node01 backups]# lltotal 42607596-rw------- 1 git git 43630172160 Nov 28 00:14 1543334067_2018_11_27_gitlab_backup.tar# 2. 执行恢复前，停止GitLab与数据库的连接，保留其他进程。[root@node01 backups]# gitlab-ctl stop unicorn[root@node01 backups]# gitlab-ctl stop sidekiq# Verify[root@node01 backups]# gitlab-ctl status# 3. 执行恢复命令[root@node01 backups]# gitlab-rake gitlab:backup:restore BACKUP=1543334067_2018_11_27Unpacking backup ... doneBefore restoring the database we recommend removing all existingtables to avoid future upgrade problems. Be aware that if you havecustom tables in the GitLab database these tables and all data will beremoved.Do you want to continue (yes/no)? yesRemoving all tables. Press `Ctrl-C` within 5 seconds to abort...# 后面一路yes，覆盖数据库、覆盖仓库、生成sshkey# # 恢复完成后要记得重启Gitlab[root@node01 backups]# gitlab-ctl restart GitLab版本升级 建议升级前按照钱数备份方式，先对GitLab数据进行备份，同时备份GitLab配置文件/etc/gitlab/gitlab.rb,然后再执行下列步骤。 1. 关闭部分GitLab服务123gitlab-ctl stop unicorngitlab-ctl stop sidekiqgitlab-ctl stop nginx 2. 升级GitLabGitLab 升级包下载地址：https://packages.gitlab.com/gitlab/gitlab-ce。下载好需要的版本上传至服务器，直接运行下列命令安装就可以了。 1rpm -Uvh gitlab-ce-10.0.4-ce.0.el7.x86_64.rpm 3. 重新配置GitLab安装完成后，根据需要修改配置文件/etc/gitlab/gitlab.rb，也可以直接使用原来备份好的gitlab.rb文件，执行重新配置命令： 1gitlab-ctl reconfigure 4. 重启GitLab1gitlab-ctl restart GitLab数据迁移GitLab数据迁移过程参照GitLab数据备份与恢复步骤操作就好了。 参考：https://gitlab.com/help/raketasks/backup_restore.mdhttps://blog.csdn.net/ouyang_peng/article/details/77070977 实验命令1234567891011mkdir -p /apps/data/gitlab/config /apps/data/gitlab/logs /apps/data/gitlab/datadocker run --detach \ --hostname 10.16.91.115 \ --publish 443:443 --publish 80:80 --publish 22222:22 \ --name gitlab \ --restart always \ --volume /apps/data/gitlab/config:/etc/gitlab \ --volume /apps/data/gitlab/logs:/var/log/gitlab \ --volume /apps/data/gitlab/data:/var/opt/gitlab \ gitlab/gitlab-ce:9.0.0-ce.0 查看GitLab版本的两个方法：123cat /opt/gitlab/embedded/service/gitlab-rails/VERSIONsudo gitlab-rake gitlab:env:info]]></content>
      <categories>
        <category>GitLab</category>
      </categories>
      <tags>
        <tag>GitLab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes Yaml Template]]></title>
    <url>%2F2019%2F05%2F05%2FKubernetes%2FKubernetes-Yaml-Template%2F</url>
    <content type="text"><![CDATA[nginx-pod.yaml1234567891011apiVersion: v1kind: Podmetadata: name: nginxspec: containers: - name: nginx image: nginx imagePullPolicy: IfNotPresent ports: - containerPort: 80 webapp-rc.yaml123456789101112131415161718192021apiVersion: v1kind: ReplicationControllermetadata: name: webappspec: replicas: 1 selector: app: webapp template: metadata: labels: app: webapp spec: containers: - name: webapp image: kubeguide/tomcat-app:v2 ports: - containerPort: 8080 env: - name: MYSQL_SERVICE_HOST value: &apos;mysql&apos; webapp-svc.yaml1234567891011apiVersion: v1kind: Servicemetadata: name: mywebappspec: type: NodePort ports: - port: 8080 nodePort: 30001 selector: app: webapp]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>Template</tag>
      </tags>
  </entry>
</search>
